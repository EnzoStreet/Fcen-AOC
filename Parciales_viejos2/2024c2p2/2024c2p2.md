En primer lugar debemos registrar la syscall en nuestra idt, esto lo haremos en idt.c, dentro de idt_init() usando idt_entry3(90) y idt_entry3(91). La primera para swap y la segunda para swap now. de esta manera cuando el kernel.asm se inbicie y se carge la idt nuestras syscall quedaran registradas y podran ser llamadas por cualquier tarea (nivel 3).

Ahora escribamos la rutina de interrupcion de nuestras sycalls. Definimos como convencion que el parametro (id_destino) nos lo va a pasar en el registro EDI.

global _isr90 ;swap

 ```asm
_isr90:
    pushad
    push EDI ;no romper los registros antes con c
    call swap_handler
    pop EDI
    popad
    iret
```
```c
//agrego una lista a cada tarea que tiene una flag por tarea indicando si quiere swap con alguna en especifico
typedef struct {
  int16_t selector;
  uint8_t swap_wanted_list[MAX_TASKS];
  task_state_t state;
} sched_entry_t;

#define SWAP(x, y) do { uint32_t tmp = (x); (x) = (y); (y) = tmp; } while(0)

```
```c
void swap_handler(int8_t id){//uso int 8 para el id ya que current task lo es
    

    if(quiereSwap(id, current_task)){//pregunto si la tarea  destino ya habia pedido swap con la tarea actual
        //si habia pedido swap, swapeo
       uint16_t idx_tarea_dst = sched_tasks[id].selector >> 3; //shifeo 3 para obtener el indice de la gdt
       tss_t* tss_dst = gdt[idx_tarea_dst].base;

       uint16_t idx_tarea_src = sched_tasks[current_task].selector >> 3;
       tss_t* tss_src = gdt[idx_tarea_src].base;

       swapTss(tss_t* tss_dst, tss_t* tss_src);
       sched_tasks[id].swap_wanted_list[current_task] = 0; //el swap ya fue atendido

       sched_enable_task(id); //prendo la que se habia quedado esperando
    } 
    //si no pidio swap, me quedo apagada esperando a que quieran swapear
    sched_tasks[current_task].swap_wanted[id] = 1; //aviso que quiero swap con tarea id, y
    sched_disable_task(current_task); //apago tarea origen 
}
```
```c
bool quiereSwap(destino, origen){
    if(sched_tasks[destino].swap_wanted[origen] == 1){
        return 1;
    }
    else{
        return 0;
    }
}
```
```c
void swapTss(dst, src){
    swap(tss_dst->esi, tss_src->esi);
    swap(tss_dst->ebx, tss_src->esi);
       ...tss->edx
       ...tss->ecx
       ...etc  
}
```

 ```asm
_isr91:
    pushad
    push EDI ;no romper los registros antes con c
    call swap_now_handler
    pop EDI
    popad
    iret
```


```c

void swap_now_handler(int8_t id){//uso int 8 para el id ya que current task lo es
    
    if(quiereSwap(id, current_task)){//pregunto si la tarea  destino ya habia pedido swap con la tarea actual
        //si habia pedido swap, swapeo
       uint16_t idx_tarea_dst = sched_tasks[id].selector >> 3; //shifeo 3 para obtener el indice de la gdt
       tss_t* tss_dst = gdt[idx_tarea_dst].base;

       uint16_t idx_tarea_src = sched_tasks[current_task].selector >> 3;
       tss_t* tss_src = gdt[idx_tarea_src].base;

       swapTss(tss_t* tss_dst, tss_t* tss_src);
       sched_tasks[id].swap_wanted_list[current_task] = 0; //el swap ya fue atendido

       sched_enable_task(id); //prendo la que se habia quedado esperando
    } 
    //si no pidio swap la id, no hago nada  
}




```





```






