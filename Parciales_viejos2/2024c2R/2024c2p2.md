## Ejercicio 1 `swap` y `swap_now`

### Registro en la IDT
Registramos nuestras syscalls en la IDT dentro de `idt.c`, en la función `idt_init()`, usando:

```c
idt_entry3(90); // syscall swap
idt_entry3(91); // syscall swap_now
```

Así, cuando se carga la IDT con `lidt [IDT_DESC]` en `kernel.asm`, estas interrupciones quedan disponibles para invocación desde tareas (nivel 3).

---

### ISR.asm
#### Para `swap`:
```asm
global _isr90
_isr90:
    pushad
    push edi ; pasamos el parámetro (id destino)
    call swap_handler
    pop edi
    popad
    iret
```

#### Para `swap_now`:
```asm
global _isr91
_isr91:
    pushad
    push edi ; pasamos el parámetro (id destino)
    call swap_now_handler
    pop edi
    popad
    iret
```

---

### Estructura de tarea (modificada)
```c

typedef struct {
  int16_t selector;
  uint8_t swap_wanted[MAX_TASKS]; // flags por tarea
  task_state_t state;
} sched_entry_t;
```

---


---

### Handler de `swap`
```c
void swap_handler(int8_t id) {
    if (quiereSwap(id, current_task)) {
        // swapeamos los registros
        uint16_t idx_dst = sched_tasks[id].selector >> 3;
        tss_t* tss_dst = (tss_t*) get_gdt_base(gdt[idx_dst]);

        uint16_t idx_src = sched_tasks[current_task].selector >> 3;
        tss_t* tss_src = (tss_t*) get_gdt_base(gdt[idx_src]);

        swapTss(tss_dst, tss_src);

        sched_tasks[id].swap_wanted[current_task] = 0;
        sched_enable_task(id); // la destino puede seguir
    }

    sched_tasks[current_task].swap_wanted[id] = 1; // aviso que quiero
    sched_disable_task(current_task); // me duermo
}
```

---

### Handler de `swap_now`
```c
void swap_now_handler(int8_t id) {
    if (quiereSwap(id, current_task)) {
        uint16_t idx_dst = sched_tasks[id].selector >> 3;
        tss_t* tss_dst = (tss_t*) get_gdt_base(gdt[idx_dst]);

        uint16_t idx_src = sched_tasks[current_task].selector >> 3;
        tss_t* tss_src = (tss_t*) get_gdt_base(gdt[idx_src]);

        swapTss(tss_dst, tss_src);

        sched_tasks[id].swap_wanted[current_task] = 0;
        sched_enable_task(id);
    }
    // si no había match, no hago nada. Ni bloqueo ni marco intención
}
```

---

### Funciones auxiliares

```c
#define SWAP(x, y) do { typeof(x) tmp = (x); (x) = (y); (y) = tmp; } while(0)
```

```c
bool quiereSwap(int destino, int origen) {
    return sched_tasks[destino].swap_wanted[origen] == 1;
}

void swapTss(tss_t* dst, tss_t* src) {
    SWAP(dst->eax, src->eax);
    SWAP(dst->ebx, src->ebx);
    SWAP(dst->ecx, src->ecx);
    SWAP(dst->edx, src->edx);
    SWAP(dst->esi, src->esi);
    SWAP(dst->edi, src->edi);
    // EBP, ESP y EIP no se tocan
}


---

- `swap` es **bloqueante**. Si no hay match, la tarea espera.
- `swap_now` es **no bloqueante**. Si no hay match, sigue en la próxima ronda.

> En `swap_now` **no se debe dejar ninguna intención persistente**, tal como aclara la consigna:  
> *"Los registros no se intercambiarán, salvo que se llame nuevamente a `swap_now` **y** la tarea destino haya hecho también la misma petición"*.

---

